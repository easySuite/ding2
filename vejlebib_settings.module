<?php

/**
 * @file
 * 
 * Module file for the Vejlebib settings module.
 *
 * Contains fixes and settings for the vejlebib instance of DDB CMS.
 */

include_once 'vejlebib_settings.features.inc';

/**
 * Implements hook_menu_alter().
 */
function vejlebib_settings_menu_alter(&$items) {
  // The library app uses this path to collect data about opening hours. During
  // the transition from ding1 to ding2, all the libraries got new nids. At this
  // point in time, we are not able to correct the values in the app, so here we
  // employ a temporary hack, that maps the library nids to the correct ones.
  // This should be removed, once the values is corrected in the library app or 
  // when the new library app is launched.
  if (isset($items['opening_hours/instances'])) {
    $item = &$items['opening_hours/instances'];
	  $item['page callback'] = 'vejlebib_settings_opening_hours_crud_api_page';	
  }
}

/**
 * Wrapper function for the opening hours page callback.
 */
function vejlebib_settings_opening_hours_crud_api_page() {
  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // Hard coded mappings from the old library nids to the new ones.
    $nid_mappings = array(
  	  1 => 13,  // Vejle
  	  2 => 16,  // Egtved
  	  3 => 17,  // Jelling
  	  35 => 15, // BÃ¸rkop
  	  36 => 14, // Give
  	  37 => 18, // Biblioteksbussen
    );
    // Seperate the old nids now for usage further down.
    $old_nids = array_keys($nid_mappings);
    // Remember what we mapped, so we can map it back in the output, to make it
    // look like the library's id is what the caller think.
    $map_back = array();
    // The nid parameter might be an array. If it's a single value, it
    // should still pass these filters with no trouble.
    // In any case, we want to elimitate bogus values, to see if
    // there's anything left to fetch.
    $nids = explode(',', $_REQUEST['nid']);
    array_filter($nids, 'is_numeric');
    array_filter($nids);
    foreach ($nids as $key => $nid) {
      if (in_array($nid, $old_nids)) {
        $nids[$key] = $nid_mappings[$nid];
    	  $map_back[] = $nid_mappings[$nid];
      }
    }
    if (!empty($_REQUEST['from_date']) && !empty($_REQUEST['to_date']) && !empty($nids)) {
      $output = opening_hours_instance_load_multiple($nids, $_REQUEST['from_date'], $_REQUEST['to_date']);
    }
    // Filter out instances on blocked days.
    // array_values is necessary, since filtered values causes holes
    // in the key order, which in turns causes json_encode to return a
    // JavaScript object instead of an array in some cases.
    $output = array_values(array_filter($output, '_opening_hours_exclude_blocked'));
    foreach ($output as $opening_hour_instance) {
    $new_nid = $opening_hour_instance->nid;
  	  if (in_array($new_nid, $map_back)) {
  	    // If the id was mapped, map it back in the output.
  	    $old_nid = array_search($new_nid, $nid_mappings);
  	    $opening_hour_instance->nid = $old_nid;
      }
    }
    return drupal_json_output($output);
  }
  // If it wasn't a GET request we fallback to the original page callback.
  return opening_hours_crud_api_page();
}

/**
 * Implements hook_preprocess_html().
 *
 * Adds meta-tags for webtrends search statistics. This could be done in a lot 
 * of ways (both in the client or on the server), but it's done here because it
 * concerns the rendering of the html-template.
 */
function vejlebib_settings_preprocess_html(&$vars) {
  $args = explode('/', current_path());
  // Determine if this is a search.
  if (!empty($args) && $args[0] == 'search' && count($args) > 2) {
    $search_engine = $args[1];
    $search_query = $args[2];
    // Find out which backend is used in the search, so we can get the results
    switch ($search_engine) {
      case 'ting':
        $search_result = drupal_static('ting_search_results');
        $search_count = $search_result->numTotalObjects;
        break;
      case 'tingextra':
        $search_result = drupal_static('ting_extrasearch_results');
        $search_count = $search_result->numTotalObjects;
        break;
      case 'node':
        // Take a sneak-peak at the pager to get the search count
        $search_count = $GLOBALS['pager_total_items'][0];
        break;
    }
    // Add the meta-tags
    $meta_tag['#tag'] = 'meta';
    $meta_tag['#attributes'] = array(
      'name' => 'WT.oss',
      'content' => $search_query,
    );
    drupal_add_html_head($meta_tag, 'search_query_meta_tag');
    $meta_tag['#attributes'] = array(
      'name' => 'WT.oss_r',
      'content' => $search_count,
    );
    drupal_add_html_head($meta_tag, 'search_count_meta_tag');     
  }
}

/**
 * Implements hook_page_build()
 *
 * Adds fallback HTML for webtrends statistics if JS is not eneabled.
 */
function vejlebib_settings_page_build(&$page) {
  $html = '<img alt="dcsimg" id="dcsimg" width="1" height="1" src="//statse.webtrendslive.com/dcs2223b10932ca7afu0mksma_6t5f/njs.gif?dcsuri=/nojavascript&amp;WT.js=No&amp;WT.tv=10.4.1&amp;dcssip=www.vejlebib.dk"/>';
  $page['page_bottom']['webtrends'] = array(
    '#prefix' => '<noscript>',
    '#suffix' => '</noscript>',
    '#markup' => $html,
  );  
}

/**
 * Implements hook_user_login().
 *
 * Removes 'ding_frontpage' from the URL, when the user is loggin in from the
 * frontpage.
 */
function vejlebib_settings_user_login(&$edit, $account) {
  $destination = drupal_get_destination();
  if ($destination['destination'] == 'ding_frontpage') {
    $_GET['destination'] = '';
  }
}
